#I used ChatGPT to insert comments into this code. Code was generated by myself though
#This code comes directly from my TSP implementation
#I also used this code to help with my solution
def construct_graph(name):
    # Initialize an empty list to store half of the graph
    halfg = []
    # Open the file named 'name' in read mode
    with open(name, 'r') as file:
        # Read each line in the file
        for line in file:
            # Strip any leading/trailing whitespaces from the line and split it by whitespace
            # Convert each element to integer and store them in a list 'row'
            row = list(map(int, line.strip().split()))
            # Append the row to 'halfg'
            halfg.append(row)
        
    # Determine the number of nodes in the graph
    n = len(halfg)
    # Initialize a 2D list 'fullg' to represent the full graph with all values initialized to 0
    fullg = [[0] * n for _ in range(n)]

    # Fill in the upper triangle of 'fullg' using values from 'halfg'
    for x in range(n):
        for y in range(x+1):
            fullg[x][y] = halfg[x][y]
            # Reflect the values across the diagonal to fill in the lower triangle
            fullg[y][x] = halfg[x][y]
    # Return the fully constructed adjacency matrix
    return fullg

#This code constructs the complement graph give a file name
def construct_complement_graph(file):
    #Call construct graph to get the original graph
    comp = construct_graph(file)
    #loop through every element in the matrix, excluding the first row and column. This is becuase those rows represent the name of nodes.
    for i in range(1, len(comp)):
        for j in range(1, len(comp)):
            if comp[i][j] == 0:
                comp[i][j] = 1
            elif comp[i][j] == 1:
                comp[i][j] = 0
    return comp

#THIS CODE IS USED IN THE BRUTE FORCE ALGORITHM
#Checks to see if you have a clique
def is_clique(v, n): #v represents vertices, n represents nodes
    # Iterate over all pairs of vertices in the set. Ignoring the first row and column
    # I ignored the first row and column because that represents the name of the nodes.
    for i in range(1, n-1):
        for j in range(i + 1, n-1):
            # If there is no edge between the vertices, return False
            if graph[v[i]][v[j]] == 0:
                return False
    # If all pairs of vertices are connected, return True (indicating a clique)
    return True

#THIS IS MY BRUTE FORCE ALGORITHM
#In this segment of code, I attempted to implement a recursive algorithm to try and brute force the Max Clique
def BF_max_clique(startV, size):
    # Initialize the maximum clique size
    max_ = 0
    # Iterate over the vertices starting from 'start_vertex_index'
    for vertex_index in range(startV + 1, num_vertices):
        # Add the vertex to the clique
        store[size] = vertex_index
        # If the current set of vertices forms a clique
        if is_clique(store, size + 1):
            # Update the maximum clique size
            max_ = max(max_, size)
            # Recursively explore larger cliques starting from the next vertex
            max_ = max(max_, BF_max_clique(vertex_index, size + 1))
    # Return the maximum clique size found
    return max_

#THIS CODE IS USED TO FIND THE MAX CLIQUE USING THE VERTEX COVER
def vertex_cover(matrix):
    # Initialize an empty list to store the vertices in the vertex cover
    cover = []
    # Iterate through each cell in the adjacency matrix
    for i in range(len(matrix)):
        for j in range(len(matrix)):
            # If an edge is found (value 1), add both vertices to the cover
            if matrix[i][j] == 1:
                # Add vertex i to the cover if it's not already in the cover
                if i not in cover:
                    cover.append(i)
                # Add vertex j to the cover if it's not already in the cover
                if j not in cover:
                    cover.append(j)
    # Return the vertex cover
    return cover

#To find the Max Clique from the Vertex Cover, you need find the vertex cover of the complement graph
#This will give you the max clique of the original graph. 
def MC_from_VC(file):
    # Construct the complement graph from the input file
    matrix = construct_complement_graph(file)
    # Find the vertex cover of the complement graph
    cover = vertex_cover(matrix)
    # Return the size of the vertex cover
    return len(cover)

#This code implements a Greedy Max clique algorithm. It's fast but not to effective
def G_max_clique(matrix):
    # Initialize an empty set to store the current clique
    clique = set()
    # Initialize a set of vertices to be candidates for the clique
    vertices = set(range(len(matrix)))
    # Iterate through each vertex in sorted_vertices
    for vertex in vertices:
        # If adding vertex to the current clique doesn't violate the clique property
        if all(matrix[vertex][v] for v in clique):
            # Add vertex to the current clique
            clique.add(vertex)
    # Return the length of the maximum clique found
    return len(clique)

file = "Q15V100.adjmat"  # Change the filename as needed
graph = construct_graph(file)
#Used in the Brute Force Implementation of my code.
num_vertices = len(graph)
# Initialize an array to store vertices in a clique. Used in the Brute Force implmentation of my code. 
store = [0] * len(graph)
# Find and print the size of the maximum clique starting from vertex 0 with a clique size of 1
print(f'For file: {file}')
print(f'Max Clique of the Brute force Algorithm: {BF_max_clique(0, 1)}')
print(f'Max Clique using the Vertex Cover of the Complement Graph: {MC_from_VC(file)}')
print(f'Max Clique using my Competitive Algorithm(Greedy): {G_max_clique(graph)}')
