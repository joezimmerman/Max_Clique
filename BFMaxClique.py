#I used ChatGPT to insert comments into this code. Code was generated by myself though
#This code comes directly from my TSP implementation
#I also used this code to help with my solution
def construct_graph(name):
    # Initialize an empty list to store half of the graph
    halfg = []
    # Open the file named 'name' in read mode
    with open(name, 'r') as file:
        # Read each line in the file
        for line in file:
            # Strip any leading/trailing whitespaces from the line and split it by whitespace
            # Convert each element to integer and store them in a list 'row'
            row = list(map(int, line.strip().split()))
            # Append the row to 'halfg'
            halfg.append(row)
        
    # Determine the number of nodes in the graph
    n = len(halfg)
    # Initialize a 2D list 'fullg' to represent the full graph with all values initialized to 0
    fullg = [[0] * n for _ in range(n)]

    # Fill in the upper triangle of 'fullg' using values from 'halfg'
    for x in range(n):
        for y in range(x+1):
            fullg[x][y] = halfg[x][y]
            # Reflect the values across the diagonal to fill in the lower triangle
            fullg[y][x] = halfg[x][y]
    # Return the fully constructed adjacency matrix
    return fullg

#Checks to see if you have a clique
def is_clique(v, n): #v represents vertices, n represents nodes
    # Iterate over all pairs of vertices in the set. Ignoring the first row and column
    # I ignored the first row and column because that represents the name of the nodes.
    for i in range(1, n-1):
        for j in range(i + 1, n-1):
            # If there is no edge between the vertices, return False
            if graph[v[i]][v[j]] == 0:
                return False
    # If all pairs of vertices are connected, return True (indicating a clique)
    return True

#In this segment of code, I attempted to implement a recursive algorithm to try and brute force the Max Clique
def BF_max_clique(startV, size):
    # Initialize the maximum clique size
    max_ = 0
    # Iterate over the vertices starting from 'start_vertex_index'
    for vertex_index in range(startV + 1, num_vertices):
        # Add the vertex to the clique
        store[size] = vertex_index
        # If the current set of vertices forms a clique
        if is_clique(store, size + 1):
            # Update the maximum clique size
            max_ = max(max_, size)
            # Recursively explore larger cliques starting from the next vertex
            max_ = max(max_, BF_max_clique(vertex_index, size + 1))
    # Return the maximum clique size found
    return max_

# Specify the file containing the adjacency matrix
file = 'Q15V100.adjmat'
# Construct the graph from the adjacency matrix
graph = construct_graph(file)

# Determine the number of vertices in the graph
num_vertices = len(graph)
# Initialize an array to store vertices in a clique
store = [0] * num_vertices

# Find and print the size of the maximum clique starting from vertex 0 with a clique size of 1
print(BF_max_clique(0, 1))
